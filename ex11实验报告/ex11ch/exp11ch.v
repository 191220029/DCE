
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module exp11ch(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [7:0]keycode;
wire [7:0]ascii;
reg [7:0]cnt = 8'h00;
reg e_out;
wire ready;
reg next_data_n = 0;
reg caps_state = 0;
reg ctrl_state = 0;
reg shift_state = 0;
reg release_flag = 0;
reg [7:0]temp;

reg enable;
wire [7:0]ascii_in;
wire [23:0]vga_data;
reg [23:0]data = 24'hffffff;
wire [9:0] h_addr;
wire [9:0] v_addr;
wire[11:0]last_index;
//=======================================================
//  Structural coding
//=======================================================


//---------keyboard------------->

assign LEDR[5] = e_out;
assign LEDR[9] = caps_state;
assign LEDR[8] = shift_state;
assign LEDR[7] = ctrl_state;

keyboard keyboard1(CLOCK_50,SW[0],PS2_CLK,PS2_DAT,keycode,ready,next_data_n,LEDR[0]);
kbdecoder decode1(temp, ascii, shift_state, caps_state, ctrl_state);
/*
hex15 h0(temp[3:0],HEX0, e_out);
hex15 h1(temp[7:4],HEX1, e_out);

hex15 h2(ascii[3:0],HEX2, e_out);
hex15 h3(ascii[7:4],HEX3, e_out);

hex15 h4(cnt[3:0],HEX4, 1'b1);
hex15 h5(cnt[7:4],HEX5, 1'b1);
*/
always@(posedge CLOCK_50) begin
	if(ready == 1 && next_data_n == 1)begin
		temp <= keycode;
		next_data_n <= 0;
		if(keycode == 8'hf0) begin//realse
			release_flag <= 1;
			cnt <= cnt + 1;
		end
		else if(keycode == 8'h12 || keycode == 8'h59) begin//shift
			enable <= 0;
			if(release_flag) begin
				shift_state <= 0;
				e_out <= 0;
				release_flag <= 0;
			end
			else begin
				shift_state <= 1;
				e_out <= 1;
			end
		end
		else if(keycode == 8'h14) begin //ctrl
			enable <= 0;
			if(release_flag) begin
				ctrl_state <= 0;
				e_out <= 0;
				release_flag <= 0;
			end
			else begin
				ctrl_state <= 1;
				e_out <= 1;
			end
		end
		else begin
			if(release_flag) begin
				e_out <= 0;
				release_flag <= 0;
				enable <= 0;
				if(keycode == 8'h58) caps_state <= ~caps_state;
				else;
			end
			else begin 
				e_out <= 1;
				enable <= 1;
			end
		end
	end
	else begin
		next_data_n <= 1;
	end
end


//------------------------------<
//----------vga----------------->
/*
wire [23:0]vga_data;
reg [23:0]data = 24'hffffff;
wire [9:0] h_addr;
wire [9:0] v_addr;
assign VGA_R = vga_data[23:16];
assign VGA_G = vga_data[15:8];
assign VGA_B = vga_data[7:0];

assign VGA_SYNC_N = 1'b0;
*/

assign ascii_in = ascii & {{7{enable}},enable};


vga_char ch(CLOCK_50, VGA_CLK, ascii_in, VGA_BLANK_N,VGA_B,VGA_G,VGA_HS,VGA_R,VGA_SYNC_N,VGA_VS);



//vga_ctrl ctrl2(pclk,reset,vga_data,[9:0] h_addr,[9:0] v_addr,hsync,vsync,valid,[7:0] vga_r,[7:0] vga_g,[7:0] vga_b);
//vga_ctrl ctrl0(VGA_CLK, SW[1], data, h_addr, v_addr, VGA_HS, VGA_VS, VGA_BLANK_N, vga_data[23:16], vga_data[15:8], vga_data[7:0]);

/*
//横向条纹
always @(h_addr) begin 
	if(h_addr < 20) 
		data = 24'h000000;
	else if(h_addr < 21 + 200 && h_addr > 19)
		data = 24'h0000ff;
	else if(h_addr < 20 + 400)
		data = 24'hf8f8ff;
	else if(h_addr < 20 + 600)
		data = 24'hdc143c;
	else data = 24'h000000;
end
*/
endmodule
